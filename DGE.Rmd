---
title: ' Differential Gene Expression Analysis Notebook'
output:
  html_document: 
    toc: yes
    fig_width: 12
    fig_height: 6
    fig_caption: yes
---

```{r}
library("DESeq2")
library("PoiClaClu")
library("pheatmap")
library("RColorBrewer")
library('tidyverse')
library("PoiClaClu")
library("vsn")
library('EnhancedVolcano')
library('gplots')
library('org.Mm.eg.db')
library('stringr')
library("genefilter")
library("dplyr")
library("ggplot2")
library("glmpca")
library('org.Mm.eg.db')
library("AnnotationDbi")
library("apeglm")
library("ComplexHeatmap")
library('Rsubread')
library("clusterProfiler")
library('clusterProfiler')
library('PCAtools')
library("wesanderson")
```

# Differential Gene Expression Analysis

## Creating metadata for the DGE Analysis

DESeq2 needs sample information (metadata) for performing DGE analysis. Let’s create the sample information

```{r}
# Read the csv file and change the column name 
sample_ID <- read.csv("~/R/Rtuts/Data/Alina_EPEC_project/samples.csv")
#names(sample_ID)[2]  <- 'Sample_Name'
head(sample_ID)
```

```{r}
condition = c("Infected","Infected","Infected","Infected","Infected","Infected","Infected","Infected","Infected","Infected","Infected","Infected","Infected","Infected","Infected","Infected","Infected","Infected","Infected","control","control")
```

```{r}
coldata <- data.frame(sample_ID, condition)
colnames(coldata) <- c('Sample_Name','condition') # change name of one of the columns
#coldata <- subset (coldata, select = -Number)
```

The metadata can be found in a df called coldata!
```{r}
head(coldata)
```

### Tidying up the names for plots later!

####First from coldata

```{r}

coldata$Samples <- coldata$Sample_Name # Adding additonal column of sample names apart from exisiting column.
coldata$Samples
```

```{r}
# tidying up the names od samples in both columns that list of samples
coldata$Samples <- str_remove_all(coldata$Samples, 
                                  pattern = c("run6_trimmed_|_.bam|_S\\d\\d|_S\\d")
                                  )
coldata$Sample_Name <- str_remove_all(coldata$Samples, 
                                  pattern = c("run6_trimmed_|_.bam|_S\\d\\d|_S\\d")
                                  )

coldata$condition <- as.factor(coldata$condition)
coldata <- data.frame(coldata, row.names = 1) # convert column1 with sample names to row.names of coldata
head(coldata)
```

#### then fix Countsmatrix:

NOTE:

1. From the manuals the countsData must be a numeric matrix
2. It is IMPORTANT to keep the names of the genes in the rownames


```{r}
countsmatrix <-as.matrix(read.csv("~/R/Rtuts/Data/Alina_EPEC_project/counts.csv"))
```

```{r}
#tidying up these names again
colnames(countsmatrix) <- str_remove_all(colnames(countsmatrix), 
                                  pattern = c("run6_trimmed_|_.bam|_S\\d\\d|_S\\d")
                                  ) 
rownames(countsmatrix) <- countsmatrix[,1] #converting first column of gene names into rownames, to be used for sanity check later
# It is IMPORTANT to keep the names of the genes in the rownames
countsmatrix<- subset (countsmatrix, select = -X)#dropping the X column
colnames(countsmatrix)
```


```{r}
# Convert the countsmatrix elements to be of numeric type in order to be in correct format to be fed into DESeq2 functions
class(countsmatrix) <- "numeric"
dim(countsmatrix)
```


# Differential Gene Expression analysis using DESeq2


Now, construct DESeqDataSet for DGE analysis.

But before that, a sanity check : It is essential to have the name of the columns in the count matrix in the same order as that in name of the samples (rownames in coldata).

```{r}
all(rownames(coldata) %in% colnames(countsmatrix))
ncol(countsmatrix) == nrow(coldata)
```

## Creating the DESeq Data set Object
```{r}
dds <- DESeqDataSetFromMatrix(countData = countsmatrix, 
                              colData = coldata, 
                              design = ~ condition)
```

## Exploratory Data Analysis and Visualization

### Pre-filtering the dataset

Our count matrix with our DESeqDataSet contains many rows with only zeros, and additionally many rows with only a few fragments total. In order to reduce the size of the object, and to increase the speed of our functions, we can remove the rows that have no or nearly no information about the amount of gene expression. 

Applying the most minimal filtering rule: removing rows of the DESeqDataSet that have no counts, or only a single count across all samples. Additional weighting/filtering to improve power is applied at a later step in the workflow.

```{r}
nrow(dds)
```

```{r}
keep <- rowSums(counts(dds)) > 1
dds <- dds[keep,]
nrow(dds)
```

```{r}
(32886/55357)* 100
```


### The variance stabilizing transformation and the rlog

#### Data needs to be homeoskedastic!

- common statistical methods for exploratory analysis of multidimensional data, for example clustering and principal components analysis (PCA), work best for data that is Homeoskedastic!

- Homeoskedastic: data that generally has the same range of variance at different ranges of the mean values.

- Problem (For RNA-seq counts):  the expected variance grows with the mean.
If one performs PCA directly on a matrix of counts or normalized counts (e.g. correcting for differences in sequencing depth), the resulting plot typically depends mostly on the genes with highest counts because they show the largest absolute differences between samples.

- Solution: simple and often used strategy to avoid this is to take the logarithm of the normalized count values plus a pseudocount of 1.

- Problem again! - now the genes with the very lowest counts will contribute a great deal of noise to the resulting plot, because taking the logarithm of small counts actually inflates their variance. 

- Result: The logarithm with a small pseudocount amplifies differences when the values are close to 0. The low count genes with low signal-to-noise ratio will overly contribute to sample-sample distances and PCA plots.

- Solution: DESeq2 offers two transformations for count data that stabilize the variance across the mean:

1. the variance stabilizing transformation (VST) for negative binomial data with a dispersion-mean trend (Anders and Huber 2010), implemented in the vst function, 
2. regularized-logarithm transformation or rlog (Love, Huber, and Anders 2014).

- For genes with high counts, both the VST and the rlog will give similar result to the ordinary log2 transformation of normalized counts.

- For genes with lower counts, the values are shrunken towards a middle value. The VST or rlog-transformed data then become approximately homoskedastic (more flat trend in the meanSdPlot), and can be used directly for computing distances between samples, making PCA plots, or as input to downstream methods which perform best with homoskedastic data.

## Applying VST transformation

```{r}
vsd <- vst(dds, blind = FALSE)
head(assay(vsd), 3)
```

```{r}
colData(vsd)
```

### applying rlog Transformation

```{r}
rld <- rlog(dds, blind = FALSE)
head(assay(rld), 3)
```

Scatterplot of transformed counts from two samples. 

While the rlog is on roughly the same scale as the log2 counts, the VST has a upward shift for the smaller values. It is the differences between samples (deviation from y=x in these scatterplots) which will contribute to the distance calculations and the PCA plot.

```{r}
dds <- estimateSizeFactors(dds)

df <- bind_rows(
  as_data_frame(log2(counts(dds, normalized=TRUE)[, 1:2]+1)) %>%
         mutate(transformation = "log2(x + 1)"),
  as_data_frame(assay(vsd)[, 1:2]) %>% mutate(transformation = "vst"),
  as_data_frame(assay(rld)[, 1:2]) %>% mutate(transformation = "rlog"))
  
colnames(df)[1:2] <- c("x", "y")  

lvls <- c("log2(x + 1)", "vst", "rlog")
df$transformation <- factor(df$transformation, levels=lvls)

ggplot(df, aes(x = x, y = y)) + geom_hex(bins = 80) +
  coord_fixed() + facet_grid( . ~ transformation)
```


## Sample Distances

useful first step in an RNA-seq analysis is often to assess overall similarity between samples: 

1. Which samples are similar to each other, which are different? 

2. Does this fit to the expectation from the experiment’s design?


### Euclidean Distance between samples

dist to calculate the Euclidean distance between samples. To ensure we have a roughly equal contribution from all genes, we use it on the VST data.
```{r}
sampleDists <- dist(t(assay(vsd)))
head(sampleDists)
```

visualize the distances in a heatmap


```{r}
sampleDistMatrix <- as.matrix( sampleDists )
rownames(sampleDistMatrix) <- vsd$Samples 
colnames(sampleDistMatrix) <- vsd$Samples
```

```{r}
colors <- colorRampPalette( rev(brewer.pal(9, "Paired")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         col = colors)
```


### Poisson Distance between Samples

Another option for calculating sample distances is to use the Poisson Distance (Witten 2011).
This measure of dissimilarity between counts also takes the inherent variance structure of counts into consideration when calculating the distances between samples.


```{r}
poisd <- PoissonDistance(t(counts(dds)))
samplePoisDistMatrix <- as.matrix( poisd$dd )
rownames(samplePoisDistMatrix) <- dds$Samples
colnames(samplePoisDistMatrix) <- dds$Samples
```

```{r}
colors <- colorRampPalette( rev(brewer.pal(9, "Paired")) )(255)

pheatmap(samplePoisDistMatrix,
         clustering_distance_rows = poisd$dd,
         clustering_distance_cols = poisd$dd,
         col = wes_palette("BottleRocket2"))
```

### PCA Plot

```{r}
color_values = c("deepskyblue3","deepskyblue3","darkolivegreen","darkred",
                 "darkgoldenrod","darkblue","darkblue","darkorange1",
                 "darkcyan","darkorchid4","burlywood4","darkslategray",
                 "darkturquoise","deeppink2","darkgreen", "darkgreen", 
                 "brown4", "brown4","chartreuse","black","black")
```

### PCA Plot with VST Data

```{r}
plotPCA(vsd, intgroup= "Samples")
```


```{r}
plotPCA(vsd, intgroup= "Samples")
```

```{r}
plotPCA(vsd, intgroup= "condition")
```


```{r}
plotPCA(vsd, intgroup= c("condition","Samples"))
```

```{r}
pcaData <- plotPCA(vsd, intgroup = c("condition","Samples"), returnData = TRUE)
head(pcaData)
```

```{r}
percentVar <- round(100 * attr(pcaData, "percentVar"))
```

```{r}
PCAplot_vst <- ggplot(pcaData, aes(x = PC1, y = PC2, 
                                   color = Samples, 
                                   label= Samples)) +
  geom_point(size =2) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  coord_fixed() +
  scale_y_continuous(breaks=seq(-12, 12, 2))+
  scale_x_continuous(breaks=seq(-20, 20, 2))+
  ggtitle("PCA with VST data")+ 
  theme(legend.position="bottom") + 
  theme(aspect.ratio=25/75) +
  geom_text(size = 4, hjust=0, vjust=0)+
  scale_colour_manual(values = color_values)

PCAplot_vst
```

```{r}
ggsave(filename = '~/R/Rtuts/Data/Alina_EPEC_project/plots/PCA_vst_plot.tiff', 
       plot = PCAplot_vst, 
       dpi = 300,
       width = 12,
       height = 10,
       units = "in")
```

#### PCA Plot with rlog Data

```{r}
plotPCA(rld, intgroup= c("condition","Samples"), returnData = TRUE)
```

```{r}
pcaData_rld <- plotPCA(rld, intgroup = c("condition","Samples"), returnData = TRUE)
head(pcaData_rld)
```

```{r}
percentVar_rld  <- round(100 * attr(pcaData_rld, "percentVar"))
```

```{r}
PCAplot_rld <- ggplot(pcaData_rld, aes(x = PC1, y = PC2, 
                                   color = Samples, 
                                   label= Samples)) +
  geom_point(size =2) +
  xlab(paste0("PC1: ", percentVar_rld[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar_rld[2], "% variance")) +
  coord_fixed() +
  scale_y_continuous(breaks=seq(-12, 12, 2))+
  scale_x_continuous(breaks=seq(-20, 20, 2))+
  ggtitle("PCA with RLOG data")+ 
  theme(legend.position="bottom") + 
  theme(aspect.ratio=25/75) +
  geom_text(size =4, hjust=0, vjust=0)+
  scale_colour_manual(values = color_values)

PCAplot_rld
```

```{r}
ggsave(filename = '~/R/Rtuts/Data/Alina_EPEC_project/plots/PCA_rld_plot.tiff', 
       plot = PCAplot_rld, 
       dpi = 300,
       width = 12,
       height = 10,
       units = "in")
```



### PCA plot using Generalized PCA.

```{r}
gpca <- glmpca(counts(dds), L=2)
gpca.dat <- gpca$factors

```
```{r}
gpca.dat$condition <- dds$condition
gpca.dat$Samples <- dds$Samples
```

```{r}
ggplot(gpca.dat, aes(x = dim1, y = dim2, color = Samples, label = Samples)) +
  geom_point(size =3) + 
  coord_fixed() + 
  ggtitle("glmpca - Generalized PCA")+ 
  theme(legend.position="bottom") + 
  theme(aspect.ratio=25/75) +
  geom_text(size = 3, hjust=0, vjust=0)+
  scale_colour_manual(values = color_values)
```

## Hierarchical Clustering

```{r}
### Extract the rlog matrix from the object
rld_mat <- assay(rld) #assay() is function from the "SummarizedExperiment" package that was loaded when you loaded DESeq2
```


```{r}
### Compute pairwise correlation values
rld_cor <- cor(rld_mat)    ## cor() is a base R function
head(rld_cor)   ## check the output of cor(), make note of the rownames and colnames
```

```{r}
### Plot heatmap

heat.colors <- brewer.pal(6, "Paired")
```
```{r}
pheatmap(rld_cor, 
         border_color=NA,
         color = heat.colors,
         fontsize = 8, 
         fontsize_row = 10, 
         height=50,
         main = 'Heirarchical Clustering of Samples',
         )
```

## DGE Results

### Running the differential expression pipeline

```{r}
dds1 <- DESeq(dds)
#str(dds1)
```

### Building the results table

```{r}
res <- results(dds1)
head(res, 30)
```

```{r}
summary(res)
```
```{r}
head(res, 30)
```

A Problem: there a number of rows with padj that has NA. 

Reaons: 

1. If within a row, all samples have zero counts, the baseMean column will be zero, and the log2 fold change estimates, p value and adjusted p value will all be set to NA. ------>>>>>> checked and not true!

2. If a row contains a sample with an extreme count outlier then the p value and adjusted p value will be set to NA. These outlier counts are detected by Cook’s distance. Customization of this outlier filtering and description of functionality for replacement of outlier counts and refitting is described below. ------>>>>>> checked and not true!

3. If a row is filtered by automatic independent filtering, for having a low mean normalized count, then only the adjusted p value will be set to NA. Description and customization of independent filtering is described below. ------>>>>>> could be true!

 =====>>>>>> Most likely caused by automatic independent filtering due to the presence of low mean normalized counts. 
 
Solution: Obtain unfiltered DESeq2 results! (counts without automatic independent filtering and outlier removal). Then, only the genes with ALL counts set to zero will have NA for pvalues. 

```{r}
dds2 <- DESeq(dds, minReplicatesForReplace=Inf)
res2 <- results(dds2, cooksCutoff=FALSE, independentFiltering=FALSE)

```

```{r}
head(res2, 30)
```


### Results with thresholds

1. lower the false discovery rate threshold (the threshold on padj in the results table)
2. raise the log2 fold change threshold from 0 using the lfcThreshold argument of results

Both thresholds Applied!
```{r}
res2.df <- as.data.frame(res2) # convert the results table to a df
head(res2.df)
```


## MA Plot 

```{r}

resultsNames(dds2)
```

```{r}
res3 <- lfcShrink(dds2, coef="condition_Infected_vs_control", type="apeglm")
plotMA(res3, ylim = c(-3, 3))
```

```{r}
res.noshr <- results(dds2, name="condition_Infected_vs_control")
plotMA(res.noshr, ylim = c(-3, 3))
```



## Heatmap of count matrix

To explore a count matrix, it is often instructive to look at it as a heatmap.

```{r}
select <- order(rowMeans(counts(dds2,normalized=TRUE)),
                decreasing=TRUE)[1:20]
df <- as.data.frame(colData(dds2)[,c("condition","Samples")])
```

```{r}
pheatmap(assay(vsd)[select,], 
         cluster_cols=TRUE, 
         annotation_col=df,
         color = heat.colors,)
```

```{r}
pheatmap(assay(rld)[select,], 
         cluster_cols=TRUE, 
         annotation_col=df,
         color = heat.colors,)
```

## Effect of Transformations on Variance

- These set of plots depict the standard deviation of transformed data (across samples), against mean.

### Based on Shifted Log Transformation
```{r}
ntd <- normTransform(dds2)
meanSdPlot(assay(ntd))
```

### Based on Rlog Transformation

```{r}
meanSdPlot(assay(rld))
```

### Based on Variance Stabilizing Transformation


```{r}
meanSdPlot(assay(vsd))
```
## Dispersion Plots

- Its a useful diagnostic to plot the dispersion estimates.

```{r}
plotDispEsts(dds2)
```



## Annotating and Exporting Results

```{r}
columns(org.Mm.eg.db)
```

```{r}
res2.df$symbol <- mapIds(org.Mm.eg.db,
                     keys = rownames(dds),
                    column = "SYMBOL",
                    keytype="ENSEMBL",
                     multiVals="first")
```

```{r}
head(res2.df)
```

## Saving the Results

```{r}
resOrdered <- res2.df[order(res2.df$pvalue),]
head(resOrdered)
```

```{r}
write.csv(as.data.frame(resOrdered), file = "~/R/Rtuts/Data/Alina_EPEC_project/results2.csv")
```

## Z-score based Gene Heatmaps

```{r}
head(res2.df)
```
### with Whole table (all genes together!)

Applying thresholds for Log2FC and pvalue

```{r}
sigs.df <- res2.df[(abs(res2.df$log2FoldChange)>1) & (res2.df$pvalue< 0.05),]
```

```{r}
mat <- counts(dds2, normalized = TRUE)[rownames(sigs.df),]
mat.zs <- t(apply(mat, 1, scale)) # Calculating the zscore for each row
colnames(mat.zs) <- coldata$Samples # need to provide correct sample names for each of the columns
head(mat.zs)
```

```{r}
Heatmap(mat.zs,
        cluster_columns = T,
        cluster_rows = F,
        column_labels = colnames(mat.zs),
        name = 'Z-Score Heatmap of ALL Genes',
         
        )
```

Need to filter these results to accommodate better the heat maps and also volcano plots

### with tighter constraints (all genes together!)

```{r}
sigs1.df <- res2.df[(res2.df$baseMean > 75) & (abs(res2.df$log2FoldChange)>2) & (res2.df$pvalue< 0.05),]
```


```{r}
mat1 <- counts(dds2, normalized = TRUE)[rownames(sigs1.df),]
mat1.zs <- t(apply(mat1, 1, scale)) # Calculating the zscore for each row
colnames(mat1.zs) <- coldata$Samples # need to provide correct sample names for each of the columns
head(mat1.zs)
```
```{r}
Heatmap(mat1.zs,
        cluster_columns = TRUE,
        cluster_rows = TRUE,
        column_labels = colnames(mat1.zs),
        name = 'Z-Score Heatmap of DE Genes',
        row_labels = sigs1.df[rownames(mat1.zs),]$symbol)
```


## Volcano Plots


```{r}
p1 <- EnhancedVolcano(sigs.df,
    lab = sigs.df[rownames(mat.zs),]$symbol,
    x = 'log2FoldChange',
    y = 'pvalue',
    pCutoff = 0.05,
    FCcutoff = 1.0,
    title = 'DE Genes',
    pointSize = 1.0,
    labSize = 3.0,
    gridlines.major = TRUE,
    gridlines.minor = FALSE
    )
```

```{r}
  p1 +
  ggplot2::coord_cartesian(ylim=c(0, 12)) +
  ggplot2::scale_y_continuous(breaks=seq(0, 12, 1)) +
  ggplot2::coord_cartesian(xlim=c(-6, 8)) +
  ggplot2::scale_x_continuous(breaks=seq(-6,8, 1)) +
  coord_fixed(ratio = 25/55)
  
```
```{r}

ggplot(sigs.df, 
       aes(x=log2FoldChange , y = -log10(pvalue))) + 
  geom_point()

```


```{r}
ggplot(sigs1.df, 
       aes(x=log2FoldChange , y = log2(baseMean))
       ) + 
  geom_point()+
  geom_text(aes(label=symbol))
```
```{r}
ggplot(sigs1.df, 
       aes(x=log2FoldChange , y = -log10(pvalue))) + 
  geom_point()+
  geom_text(aes(label=symbol))
```



## GO Terms

```{r}
UPgene_names <- rownames(sigs.df[sigs.df$log2FoldChange>1,])
```

Running GO with clusterProfiler

```{r}
GO_results <- enrichGO(gene = UPgene_names,
                       OrgDb = "org.Mm.eg.db",
                       keyType = "ENSEMBL",
                       ont = "BP"
                       )
```


```{r}
GO.df <- as.data.frame(GO_results)
GO.df
```
NOTE: 67 out of 429 ENS Id found!

```{r}
GO_fit <- plot(barplot(GO_results, showCategory = 10))
```


## Data Carpentry with padj<0.05 and abs(log2FC)<-1 imposed!
```{r}
head(sigs.df)
write.csv(sigs.df ,"~/R/Rtuts/Data/Alina_EPEC_project/Data_Alina_padjANDlog2FC_thresholdimposed.csv")
```

```{r}
summary(sigs.df)
```
### Gender Genes Removed from Table

```{r}
sigs.df <- filter(sigs.df, symbol != "Xist", symbol !="Jpx", symbol !="Ftx", symbol !="Tsx", symbol != "Cnbp2" )
```


### Number of Genes from different strains that are contributing to UP/DOWN regulation.

```{r}
sigs.UP.df <- sigs.df[(sigs.df$log2FoldChange)>1, ]
sigs.DOWN.df <- sigs.df[(sigs.df$log2FoldChange)<1, ]
```


```{r}
str(sigs.UP.df)
```


```{r}
str(sigs.DOWN.df)
```



### Down Regulation - Most Important Genes

```{r}
sigs.DOWN.df$symbol <- as.factor(sigs.DOWN.df$symbol)
downgene_list <- data.frame(sigs.DOWN.df$symbol)
names(downgene_list)[1] <- 'DOWN_Genes'
summary(downgene_list, maxsum = 20)
```


```{r}
count(downgene_list)
```
### UP Regulation - Most Important Genes

```{r}
sigs.UP.df$symbol <- as.factor(sigs.UP.df$symbol)
upgene_list <- data.frame(sigs.UP.df$symbol)
names(upgene_list)[1] <- 'UP_Genes'
summary(upgene_list, maxsum = 20)
```

```{r}
write.csv(as.data.frame(sigs.df), file = "~/R/Rtuts/Data/Alina_EPEC_project/significant_genes_table.csv")
write.csv(as.data.frame(downgene_list), file = "~/R/Rtuts/Data/Alina_EPEC_project/downgene_list.csv")
write.csv(as.data.frame(upgene_list), file = "~/R/Rtuts/Data/Alina_EPEC_project/upgene_list.csv")

```


```{r}
sessionInfo( )
```
