---
title: "2D Analysis Notebook"
output:
  html_document:
    df_print: paged
---

```{r}
library(tidyverse)
library(CCA)
library(readxl)
```

# Read in the Datasets
```{r}
UpGene <- read.csv("~/Documents/AlinaRnaSeq/IvC/UpGenelist_infectedvscontrol.csv")

DownGene <- read.csv("~/Documents/AlinaRnaSeq/IvC/DownGenelist_infected_infectedvscontrol.csv")
```

## Log2FC
```{r}
l2fctable_InfectedvsControl_BL6 <- read.csv("~/2D_Analysis/l2fctable_InfectedvsControl_BL6.csv")

# filter the symbol column based on only the genes that are in UpGenes so that these are both significant and differentially regulated

l2fctable_InfectedvsControl_BL6 <- filter(l2fctable_InfectedvsControl_BL6,
                                      symbol %in% c(UpGene$x, DownGene$x))
# l2fctable_InfectedvsControl_BL6 <- filter(l2fctable_InfectedvsControl_BL6, symbol %in% UpGene$x)
```

```{r}
rownames(l2fctable_InfectedvsControl_BL6) <- l2fctable_InfectedvsControl_BL6[, 2] # make the symbols as rownames
l2fctable_InfectedvsControl_BL6 <- subset(l2fctable_InfectedvsControl_BL6, select = -c(X, symbol)) # remove the X and symbol columns
net_l2fc <- rowSums(l2fctable_InfectedvsControl_BL6, na.rm = TRUE, dims = 1)
# sum up the values in each row for every gene to get net infected gene expression
l2fctable_InfectedvsControl_BL6$net_l2fc <- net_l2fc
```

```{r}
library(stringr)
colnames(l2fctable_InfectedvsControl_BL6) <- str_remove_all(colnames(l2fctable_InfectedvsControl_BL6),
  pattern = "log2FoldChange_"
)
l2fctable_InfectedvsControl_BL6 <- l2fctable_InfectedvsControl_BL6[order(l2fctable_InfectedvsControl_BL6$net_l2fc, decreasing = TRUE), ]
head(l2fctable_InfectedvsControl_BL6)
```

## Effector Table

```{r}
effector <- as.data.frame(read_excel("~/2D_Analysis/allStrains_PresentAbsent_effectorlist_forKeshav.xlsx",
  col_types = c(
    "text", "numeric", "numeric", "numeric", "numeric",
    "numeric", "numeric", "numeric", "numeric", "numeric",
    "numeric", "numeric", "numeric", "numeric", "numeric"
  )
))
rownames(effector) <- effector[, 1] # move effectors to rownames
effector <- subset(effector, select = -...1) # remove effector symbol column
net_eff <- rowSums(effector, na.rm = TRUE, dims = 1)
effector$net_effector <- net_eff
head(effector)
```





```{r}
mc <- matcor(t(l2fctable_InfectedvsControl_BL6), t(effector))
correlate <- mc$XYcor
```
```{r fig.height=15, fig.width=15}
library(corrplot)
# corrplot(correlate, method = "color", type = "full", is.corr = TRUE, diag = TRUE)
```


```{r}
library(corrr)
corr_df <- as.data.frame(correlate) %>% fashion()
```

```{r}
# library(CCA)
# cc_results <- cor(l2fc_matrix, effectot_matrix)
```

```{r}
# x <- cor(l2fc_matrix, effector_matrix,method = c("spearman"))
#
# out <- data.frame(MaxCorr = apply(x,1,max), T_ColIndex=apply(x,1,which.max),C_ColIndex=1:nrow(x))
#
# head(out)
```
```{r}
# cancor(l2fc$net_l2fc, effector$net_effector)
```
```{r}
# library(GGally)
# ggpairs(l2fc)
```


R Canonical Correlation Analysis
```{r}
# library(corrr)
# cc1 <- cc(l2fc, effector)
```
```{r}
# compute canonical loadings
# cc2 <- comput(l2fc, effector, cc1)
```


```{r}
effnew <- read.csv("~/2D_Analysis/eff.csv")
rownames(effnew) <- effnew[, 1] # move effectors to rownames
effnew <- subset(effnew, select = - X) # remove effector symbol column
head(effnew)
```


# Factor Analysis for Mixed Data - FAMD

```{r}
library(FactoMineR)
```

```{r}
#l2fc <- l2fctable_InfectedvsControl_BL6[ c(1:28, 392:419), 1:14]
l2fc <- l2fctable_InfectedvsControl_BL6[ 1:25, 1:14]
#eff <- effector[1:6, 1:14]
l2fc[is.na(l2fc)] <- 0.0000001
```

```{r}

# eff[eff == '1'] <- 'Present'
# eff[eff == '2'] <- 'Present'
# eff[eff == '0'] <- 'Absent'
```

```{r}
l <- t(l2fc)
e <- t(effnew)

df_merge <- merge(l, e, by = 'row.names', all = TRUE)
row.names(df_merge) <- df_merge$Row.names
df_merge <- subset(df_merge, select = -Row.names)
```
```{r}
head(df_merge)
```

```{r}
res.famd <- FAMD(df_merge, graph = TRUE)
```
```{r}
res.famd$call
```
```{r}
summary.FAMD(res.famd)
```
```{r}
print.FAMD(res.famd)
```



## Eigen Value

```{r}
library("factoextra")
eig.val <- get_eigenvalue(res.famd)
head(eig.val)
```


### Visualize eigenvalues (scree plot). 

Show the percentage of variances explained by each principal component.
```{r}
eig.val <- res.famd$eig
barplot(eig.val[, 2], 
        names.arg = 1:nrow(eig.val), 
        main = "Variances Explained by Dimensions (%)",
        xlab = "Principal Dimensions",
        ylab = "Percentage of variances",
        col ="steelblue")
# Add connected line segments to the plot
lines(x = 1:nrow(eig.val), eig.val[, 2], 
      type = "b", pch = 19, col = "red")
```
##Graph of variables
```{r}
var <- get_famd_var(res.famd)
var
```

```{r}
# Cos2: quality of representation on the factore map
var$cos2
```
```{r}
# Contributions to the  dimensions
var$contrib
```

```{r fig.align='default', fig.width=10}
# Plot of variables
fviz_famd_var(res.famd, 
              repel = TRUE, 
              geom = c("point", "text"),
              axes = c(1,2),
              col.ind = "green",
              col.var.sup = "green"
              )
```
```{r fig.width=10}
# Plot of variables
fviz_famd_var(res.famd, repel = TRUE, axes = c(2,3))
```


```{r fig.width=10}
# Plot of variables
fviz_famd_var(res.famd, repel = TRUE, axes = c(3,4))
```
```{r fig.width=10}
# Plot of variables
fviz_famd_var(res.famd, repel = TRUE, axes = c(4,5))
```




```{r}
# Contribution to the first dimension
fviz_contrib(res.famd, "var", axes = 1, sort.val = "desc", top = 40)
# Contribution to the second dimension
fviz_contrib(res.famd, "var", axes = 2, sort.val = "desc", top = 40)
```
The red dashed line on the graph above indicates the expected average value, If the contributions were uniform. 

## Quantitative variables

```{r}
quanti.var <- get_famd_var(res.famd, "quanti.var")
quanti.var 
```

```{r}
fviz_famd_var(res.famd, "quanti.var", repel = TRUE)
```
Briefly, the graph of variables (correlation circle) shows the relationship between variables, the quality of the representation of variables, as well as, the correlation between variables and the dimensions. 

The most contributing quantitative variables can be highlighted on the scatter plot using the argument col.var = "contrib". This produces a gradient colors, which can be customized using the argument gradient.cols.

```{r}
fviz_famd_var(res.famd, "quanti.var", col.var = "contrib", 
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE)
```

Similarly, you can highlight quantitative variables using their cos2 values representing the quality of representation on the factor map. If a variable is well represented by two dimensions, the sum of the cos2 is closed to one. For some of the items, more than 2 dimensions might be required to perfectly represent the data.

```{r}
# Color by cos2 values: quality on the factor map
fviz_famd_var(res.famd, "quanti.var", 
              col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE,
             
             )
```
## Graph of qualitative variables

```{r}
quali.var <- get_famd_var(res.famd, "quali.var")
quali.var 
```

```{r fig.height=8, fig.width=8}
fviz_famd_var(res.famd, "quali.var", col.var = "contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07")
             )
```
## Graph of individuals

```{r}
ind <- get_famd_ind(res.famd)
ind
```
```{r fig.width=10}
fviz_famd_ind(res.famd, 
              col.ind = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE)
```
```{r fig.width=10}
fviz_famd_ind(res.famd, 
              col.ind = "contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE)
```

Individuals with similar profiles are close to each other on the factor map

Graph of individuals. Qualitative variable categories are shown in bold.

```{r fig.width=10}
#plot(res.famd, choix = "ind")
```

Correlation between variables (qualitative and quantitative) with principal dimensions:
```{r fig.width=10}
plot(res.famd, choix = "var")
```
```{r}
fviz_hmfa_quali_biplot(res.famd, 1:2, repel = TRUE, 
                       )
```



```{r}
res.desc <- dimdesc(res.famd, axes = 1:5, proba = 0.05)

```
```{r}
# Description of dimension 1
res.desc[[1]]
```
```{r}
# Description of dimension 2
res.desc[[2]]
```
```{r}
# Description of dimension 3
res.desc[[3]]
```
```{r}
# Description of dimension 4
res.desc[[4]]
```
```{r}
# Description of dimension 5
res.desc[[5]]
```
```{r}
# library(mixedCCA)
# ```
# ```{r}
# n <- 100; p1 <- 15; p2 <- 10 # sample size and dimensions for two datasets.
# maxcancor <- 0.9 # true canonical correlation
# # Correlation structure within each data set
# set.seed(0)
# perm1 <- sample(1:p1, size = p1);
# Sigma1 <- autocor(p1, 0.7)[perm1, perm1]
# blockind <- sample(1:3, size = p2, replace = TRUE);
# Sigma2 <- blockcor(blockind, 0.7)
# mu <- rbinom(p1+p2, 1, 0.5)
# 
# # true variable indices for each dataset
# trueidx1 <- c(rep(1, 3), rep(0, p1-3))
# trueidx2 <- c(rep(1, 2), rep(0, p2-2))

```

```{r}
# # Data generation
# simdata <- GenerateData(n=n, trueidx1 = trueidx1, trueidx2 = trueidx2, maxcancor = maxcancor,
#                         Sigma1 = Sigma1, Sigma2 = Sigma2,
#                         copula1 = "exp", copula2 = "cube",
#                         muZ = mu,
#                         type1 = "trunc", type2 = "trunc",
#                         c1 = rep(1, p1), c2 =  rep(0, p2)
# )
# X1 <- simdata$X1
# X2 <- simdata$X2
```




```{r}
# mixedCCAresult <- mixedCCA(X1, X2, type1 = "trunc", type2 = "trunc", BICtype = 1)
# ```
# ```{r}
# mixedCCAresult$KendallR # estimated latent correlation matrix
# ```
# ```{r}
# mixedCCAresult$w1 # estimated canonical vector for X1
# ```
# ```{r}
# mixedCCAresult$w2 # estimated canonical vector for X2
# 
# ```
# 
# ```{r}
# mixedCCAresult$cancor # estimated canonical correlation
```

